---
title: "`limma`: Linear Models for Microarray and RNA-Seq Data User's Guide"
author: "Gordon K. Smyth, Matthew Ritchie, Natalie Thorne, James Wettenhall, Wei Shi and Yifang Hu.\nBioinformatics & Computational Biology Division, The Walter and Eliza Hall Institute of Medical Research, Melbourne, Australia"
date: "First edition 2 December 2002. Last revised 14 April 2025"
output: 
  pdf_document:
    number_sections: true
---

This free open-source software implements academic research by the authors and co-workers. If you use it, please support the project by citing the appropriate journal articles listed in Section 2.1.

# Introduction

Limma is a package for the analysis of gene expression data arising from microarray or RNA-seq technologies [29]. A core capability is the use of linear models to assess differential expression in the context of multi-factor designed experiments. Limma provides the ability to analyze comparisons between many RNA targets simultaneously. It has features that make the analyses stable even for experiments with small number of arrays — this is achieved by borrowing information across genes. It is specially designed for analysing complex experiments with a variety of experimental conditions and predictors. The linear model and differential expression functions are applicable to data from any quantitative gene expression technology including microarrays, RNA-seq and quantitative PCR. Limma can handle both single-channel and two-color microarrays.

This guide gives a tutorial-style introduction to the main limma features but does not describe every feature of the package. A full description of the package is given by the individual function help documents available from the R online help system. To access the online help, type `help(package=limma)` at the R prompt or else start the html help system using `help.start()` or the Windows drop-down help menu.

Limma provides a strong suite of functions for reading, exploring and pre-processing data from two-color microarrays. The Bioconductor package marray provides alternative functions for reading and normalizing spotted two-color microarray data. The marray package provides flexible location and scale normalization routines for log-ratios from two-color arrays. The limma package overlaps with marray in functionality but is based on a more general concept of within-array and between-array normalization as separate steps. If you are using limma in conjunction with marray, see Section 6.4.

Limma can read output data from a variety of image analysis software platforms, including GenePix, ImaGene etc. Either one-channel or two-channel formats can be processed.

The Bioconductor package affy provides functions for reading and normalizing Affymetrix microarray data. Advice on how to use limma with the affy package is given throughout the User’s Guide, see for example Section 8.2 and the _E. coli_ and estrogen case studies.

Functions for reading and pre-processing expression data from Illumina BeadChips were introduced in limma 3.0.0. See the case study in Section 17.3 for an example of these. Limma can also be used in conjunction with the vst or beadarray packages for pre-processing Illumina data.

From version 3.9.19, limma includes functions to analyse RNA-seq experiments, demonstrated in Case Study 11.8. The approach is to convert a table of sequence read counts into an expression object which can then be analysed as for microarray data.

This guide describes limma as a command-driven package. Graphical user interfaces to the most commonly used functions in limma are available through the packages limmaGUI [42], for two-color data, or affylmGUI [41], for Affymetrix data. Both packages are available from Bioconductor.

This user’s guide should be correct for R Versions 2.8.0 through 4.0.0 and limma versions 2.16.0 through 3.44.0. The limma homepage is https://bioinf.wehi.edu.au/limma.

# Preliminaries

## Citing limma

...

## Installation

...

```{r, eval=FALSE}
library(BiocManager)
install("limma")
```

```{r, eval=FALSE}
install.packages("statmod")
```

```{r, eval=FALSE}
news(package = "limma")
```

```{r}
limma::changeLog(n = 20)
```

## How to get help

...

# Quick Start

## A brief introduction to R

```{r, eval=FALSE}
help.start()
```

```{r, eval=FALSE}
library(limma)
```

```{r, eval=FALSE}
?lmFit
```

```{r, eval=FALSE}
help("lmFit")
```

```{r, eval=FALSE}
x <- 2
```

```{r, eval=FALSE}
objects()
```

```{r, eval=FALSE}
show(x)
x
```

## Sample limma Session

...


# Reading Microarray Data

## Scope of this Chapter

## Recommended Files

## The Targets Frame

## Reading Two-Colour Intensity Data

## Reading Single-Channel Agilent Intensity Data

## Reading Illumina BeadChip Data

## Image-derived Spot Quality Weights

## Reading Probe Annotation

## Printer Layout

## The Spot Types File

# Quality Assessment

I think the plot in this I will have to make
the data by hand.

# Pre-Processing Two-Color Data

## Background Correction

This section uses data from https://bioinf.wehi.edu.au/folders/mixture/

## Within-Array Normalization

Not sure what data this section uses.

## Between-Array Normalization

```{r}
load("data/apoa1/Apoa1.RData")
```

```{r}
RG.b <- backgroundCorrect(RG, method = "minimum")
```

```{r}
plotDensities(RG.b)
```

```{r}
MA.p <- normalizeWithinArrays(RG.b)
plotDensities(MA.p)
```

```{r}
MA.pAq <- normalizeBetweenArrays(MA.p, method = "Aquantile")
plotDensities(MA.pAq)
```

```{r}
MA.q <- normalizeBetweenArrays(RG.b, method = "quantile")
plotDensities(MA.q, col = "black")
```

## Using Objects from the marray Package

...

# Filtering unexpressed probes

...

# Linear Models Overview

## Introduction

...

## Single-Channel Designs

...

## Common Reference Designs

Data is from https://bmcgenomics.biomedcentral.com/articles/10.1186/1471-2164-9-363

## Direct Two-Color Designs

Mireille Lahoud dendritic cell paper. Can't check which one 
because I don't have access.

# Single-Channel Experimental Designs

## Introduction

## Two Groups

Simple Wt and My mice.

## Several Groups

RNA1, RNA2, RNA3.

## Additive Models and Blocking

### Paired Samples

Compare treatment vs control. Dogs from three
sib-ships are used. Each sib-pair one dog has
T and the other C.

### Blocking

## Interaction Models: 2 x 2 Factorial Designs

### Questions of interest

Cells extracted from WT or Mu mice, then
stimulated or unstimulated.

### Analysing as for a Signle Factor

Same as previous.

### A Nested Interaction Formula

Same as previous.

### Classic Interaction Models

Same as previous.

## Time Course Experiments

### Replicated time points

RNA samples collected from WT and Mu animals
at 0, 6, and 24 h. Potentially see Peart et al. 2005  Identification and functional significance of genes regulated by structurally
different histone deacetylase inhibitors. 

### Many time points

Control and Treatment, 16 time points each.

## Multi-level experiments

6 subjects, 3 diseased and 3 normal. Two tissues types taken from each subject.

# Two-Color Experiments with a Common Reference

## Introduction

## Two Groups

WT/Mu mice vs Ref

## Several Groups

RNA1, RNA2, RNA3 vs Ref.

# Direct Two-Color Experimental Designs

## Introduction

## Simple Comparisons

### Replicate Arrays

wt vs mu RNA

### Dye Swaps

wt vs mu RNA

### A Correlation Approach to Technical Replication

wt vs mu mice.

# Separate Channel Analysis of Two-Color Data

wt vs mu, young vs old, animals.

# Statistics for Differential Expression

## Summary Top-Tables

## Fitted Model Objects

## Multiple Testing Across Contrasts

# Array Quality Weights

## Introduction

## Example 1

Data is from https://bioinf.wehi.edu.au/folders/arrayweights/

## Example 2

Apoa1.

## When to Use Array Weights

# RNA-Seq Data

## Introduction

## Making a count matrix

## Normalization and filtering

## Differential expression: limma-trend

## Differential expression: voom

## Voom with sample quality weights

GSE64099

## Differential expresion: voomLmFit

## Differential splicing

# Two-color Case Studies

## Swirl Zebrafish: A Single-Group Experiment

In this section we consider a case study in which two RNA sources are compared directly on a set of replicate or dye-swap arrays. The case study includes reading in the data, data display and exploration, as well as normalization and differential expression analysis. The analysis of differential expression is analogous to a classical one-sample test of location for each gene.

In this example we assume that the data is provided as a GAL file called `fish.gal` and raw SPOT output files and that these files are in the current working directory. The data used for this case study can be downloaded from `https://bioinf.wehi.edu.au/limmaGUI/DataSets.html`.

```{r}
dir("data/swirl")
```


**Background.** The experiment was carried out using zebrafish as a model organism to study the early development in vertebrates. Swirl is a point mutant in the BMP2 gene that affects the dorsal/ventral body axis. The main goal of the Swirl experiment is to identify genes with altered expression in the Swirl mutant compared to wild-type zebrafish.

**The hybridizations.** Two sets of dye-swap experiments were performed making a total of four repli- cate hybridizations. Each of the arrays compares RNA from swirl fish with RNA from normal (“wild type”) fish. The experimenters have prepared a tab-delimited targets file called `SwirlSamples.txt` which describes the four hybridizations:

```{r}
library(limma)
targets <- readTargets("data/swirl/SwirlSample.txt")
targets
```

We see that slide numbers 81, 82, 93 and 94 were used to make the arrays. On slides 81 and 93, swirl RNA was labeled with green (Cy3) dye and wild type RNA was labeled with red (Cy5) dye. On slides 82 and 94, the labelling was the other way around.

Each of the four hybridized arrays was scanned on an Axon scanner to produce a TIFF image, which was then processed using the image analysis software SPOT. The data from the arrays are stored in the four output files listed under `FileName`. Now we read the intensity data into an `RGList` object in R. The default for SPOT output is that `Rmean` and `Gmean` are used as foreground intensities and `morphR` and `morphG` are used as background intensities:

```{r}
RG <- read.maimages(targets, source = "spot", path = "data/swirl")
RG
```

**The arrays.** The microarrays used in this experiment were printed with 8448 probes (spots), including 768 control spots. The array printer uses a print head with a 4x4 arrangement of print-tips and so the microarrays are partitioned into a 4x4 grid of tip groups. Each grid consists of 22x24 spots that were printed with a single print-tip.

Unlike most image analysis software, SPOT does not store probe annotation in the output files, so we have to read it separately. The gene name associated with each spot is recorded in a GenePix array list (GAL) file:

```{r}
RG$genes <- readGAL("fish.gal", path = "data/swirl")
RG$genes[1:30, ]
```

Because we are using SPOT output, the 4x4x22x24 print layout also needs to be set. The easiest way to do this is to infer it from the GAL file:

```{r}
RG$printer <- getLayout(RG$genes)
```

Image plots. It is interesting to look at the variation of background values over the array. Consider image plots of the red and green background for the first array:

```{r}
imageplot(log2(RG$Rb[, 1]), RG$printer, low = "white", high = "red")
imageplot(log2(RG$Gb[, 1]), RG$printer, low = "white", high = "green")
```

Image plot of the un-normalized log-ratios or M-values for the first array:

```{r}
MA <- normalizeWithinArrays(RG, method = "none")
imageplot(MA$M[, 1], RG$printer, zlim = c(-3, 3))
```

The `imageplot` function lies the slide on its side, so the first print-tip group is bottom left in this plot. We can see a red streak across the middle two grids of the 3rd row caused by a scratch or dust on the array. Spots which are affected by this artifact will have suspect M-values. The streak also shows up as darker regions in the background plots.

**MA-plots.** An MA-plot plots the log-ratio of R vs G against the overall intensity of each spot. The log-ratio is represented by the M-value, M = log2(R) - log2(G), and the overall intensity by the A-value, A = (log2(R) + log2(G))/2. Here is the MA-plot of the un-normalized values for the first array:

```{r}
plotMD(MA)
```

The red streak seen on the image plot can be seen as a line of spots in the upper right of this plot. Now we plot the individual MA-plots for each of the print-tip groups on this array, together with the loess curves which will be used for normalization:

```{r}
plotPrintTipLoess(MA)
```

**Normalization.** Print-tip loess normalization:

```{r}
MA <- normalizeWithinArrays(RG)
plotPrintTipLoess(MA)
```

We have normalized the M-values with each array. A further question is whether normalization is required between the arrays. The following plot shows overall boxplots of the M-values for the four arrays.

```{r}
boxplot(MA$M ~ col(MA$M), names = colnames(MA$M))
```

There is evidence that the different arrays have different spreads of M-values, so we will scale normalize between the arrays.

```{r}
MA <- normalizeBetweenArrays(MA, method = "scale")
boxplot(MA$M ~ col(MA$M), names = colnames(MA$M))
```

Note that scale-normalization is not done routinely for all two-color data sets, in fact it is rarely done with newer platforms. However it does give good results on this data set. It should only be done when there is good evidence of a scale difference in the M-values.

**Linear model.** First setup an appropriate design matrix. The negative numbers in the design matrix indicate the dye-swaps:

```{r}
design <- modelMatrix(targets, ref = "wild type")
design
```

Now fit a simple linear model for each gene. This has the effect of estimating the average M-value for each gene, adjusting for the dye-swaps.

```{r}
fit <- lmFit(MA, design)
fit
```

In the above fit object, `coefficients` is the average M-value for each gene and `sigma` is the sample standard deviations for each gene. Ordinary *t*-statistics for comparing mutant to wt could be computed by

```{r, eval=FALSE}
ordinary.t <- fit$coefficients / fit$stdev.unscaled / fit$sigma
```

We prefer though to use empirical Bayes moderated *t*-statistics which are computed below.

Now create an mean difference plot displaying the log-fold-changes and average A-values for each
gene.

```{r}
plotMD(fit)
abline(0, 0, col = "blue")
```

**Empirical Bayes analysis.** We will now go on and compute empirical Bayes statistics for differential expression. The moderated *t*-statistics use sample standard deviations which have been squeezed towards a pooled standard deviation value.

```{r}
fit <- eBayes(fit)
qqt(fit$t, df = fit$df.prior + fit$df.residual, pch = 16, cex = 0.2)
abline(0, 1)
```

Visually there seems to be plenty of genes which are differentially expressed. We will obtain a summary table of some key statistics for the top genes.

```{r}
options(digits = 3)
topTable(fit, number = 30)
```

The top gene is BMP2 which is significantly down-regulated in the Swirl zebrafish, as it should be because the Swirl fish are mutant in this gene. Other positive controls also appear in the top 30 genes in terms.

In the table, `t` is the empirical Bayes moderated *t*-statistic, the corresponding P-values have been adjusted to control the false discovery rate and `B` is the empirical Bayes log odds of differential expression.

```{r}
plotMD(fit)
top30 <- order(fit$lods, decreasing = TRUE)[1:30]
text(fit$Amean[top30], fit$coefficients[top30], labels = fit$genes[top30, "Name"], cex = 0.8, col = "blue")
```

## Apoa1 Knockout Mice: A Two-Group Common-Reference Experiment

In this section we consider a case study where two RNA sources are compared through a common reference RNA. The analysis of the log-ratios involves a two-sample comparison of means for each gene.

In this example we assume that the data is available as an `RGList` in the data file `Apoa1.RData`. The data used for this case study can be downloaded from `https://bioinf.wehi.edu.au/limma`.

**Background.** The data is from a study of lipid metabolism by [3]. The apolipoprotein AI (Apoa1) gene is known to play a pivotal role in high density lipoprotein (HDL) metabolism. Mice which have the Apoa1 gene knocked out have very low HDL cholesterol levels. The purpose of this experiment is to determine how Apoa1 deficiency affects the action of other genes in the liver, with the idea that this will help determine the molecular pathways through which Apoa1 operates.

**Hybridizations.** The experiment compared 8 Apoa1 knockout mice with 8 normal C57BL/6 (”black six”) mice, the control mice. For each of these 16 mice, target mRNA was obtained from liver tissue and labelled using a Cy5 dye. The RNA from each mouse was hybridized to a separate microarray. Common reference RNA was labelled with Cy3 dye and used for all the arrays. The reference RNA was obtained by pooling RNA extracted from the 8 control mice.

```{r, echo=FALSE}
knitr::kable(
  data.frame(
    "Number of arrays" = rep(8, 2),
    "Red" = c('Normal "black six" mice', "Apoa1 knockout"),
    "Green" = rep("Pooled reference", 2),
    check.names = FALSE
  )
)
```

This is an example of a single comparison experiment using a common reference. The fact that the comparison is made by way of a common reference rather than directly as for the swirl experiment makes this, for each gene, a two-sample rather than a single-sample setup.

```{r}
load("data/Apoa1.RData")
# objects()
names(RG)
RG$targets
MA <- normalizeWithinArrays(RG)
cols <- MA$targets$Cy5
cols[cols == "C57BL/6"] <- "blue"
cols[cols == "ApoAI-/-"] <- "yellow"
boxplot(MA$M ~ col(MA$M), names = rownames(MA$targets), col = cols, xlab = "Mouse", ylab = "M-values")
```

Since the common reference here is a pool of the control mice, we expect to see more differences from the pool for the knock-out mice than for the control mice. In terms of the above plot, this should translate into a wider range of M-values for the knock-out mice arrays than for the control arrays, and we do see this. Since the different arrays are not expected to have the same range of M-values, between-array scale normalization of the M-values is not appropriate here.

Now we can go on to estimate the fold change between the two groups. In this case the design matrix has two columns. The coefficient for the second column estimates the parameter of interest, the log-ratio between knockout and control mice.

```{r}
design <- cbind("Control-Ref" = 1, "KO-Control" = MA$targets$Cy5 == "ApoAI-/-")
design
fit <- lmFit(MA, design)
fit$coef[1:5, ]
fit <- eBayes(fit)
options(digits = 3)
```

Normally at this point one would just type

```r
topTable(fit, coef = 2)
```

However, the gene annotation is a bit wide for the printed page, so we will tell `topTable()` to show just one column of the annotation information:

```{r}
topTable(fit, coef = 2, number = 15, genelist = fit$genes$NAME)
```

Notice that the top gene is Apoa1 itself which is heavily down-regulated. Theoretically the M-value should be minus infinity for Apoa1 because it is the knockout gene. Several of the other genes are closely related. The top eight genes here were confirmed by independent assay subsequent to the microarray experiment to be differentially expressed in the knockout versus the control line.

```{r}
volcanoplot(fit, coef = 2, highlight = 8, names = fit$genes$NAME, main = "KO vs Control")
```

## Weaver Mutant Mice: A Composite 2x2 Factorial Experiment

### Background

This case study considers a more involved two-color analysis in which the RNA sources have a factorial structure with two factors.

The study examined the development of neurons in wild-type and weaver mutant mice [7]. The weaver mutation affects cerebellar granule neurons, the most numerous cell-type in the central ner- vous system. Weaver mutant mice are characterized by a weaving gait. Granule cells are generated in the first postnatal week in the external granule layer of the cerebellum. In normal mice, the terminally differentiated granule cells migrate to the internal granule layer but in mutant mice the cells die before doing so, meaning that the mutant mice have strongly reduced numbers of cells in the internal granule layer. The expression level of any gene which is specific to mature granule cells, or is expressed in response to granule cell derived signals, is greatly reduced in the mutant mice.

### Sample Preparation and Hybridizations

At each time point (P11 = 11 days postnatal and P21 = 21 days postnatal) cerebella were isolated from two wild-type and two mutant littermates and pooled for RNA isolation. RNA was then divided into aliquots and labelled before hybridizing to the arrays. (This means that aliquots are technical replicates, arising from the same mice and RNA extraction. In our analysis here, we will ignore this complication and will instead treat the aliquots as if they were biological replicates. See Yang and Speed (2002) for a detailed discussion of this issue in the context of this experiment.) A pool of RNA was also made by combining the different RNA samples.

There are four different treatment combinations, P11wt, P11mt, P21wt and P21mt, comprising a 2x2 factorial structure. The RNA samples were hybridized to ten two-color microarrays, spotted with a 20k Riken clone library. There are six arrays comparing the four different RNA sources to the RNA pool, and four arrays making direct comparisons between the four treatment combinations.

The microarray images were scanned using SPOT image analysis software.

### Data input

The data used for this case study can be downloaded from `http://bioinf.wehi.edu.au/limma/ data/weaverfull.rar`. The data are provided courtesy of Drs Jean Yang and Elva Diaz.

First read in the targets frame:

```{r}
library(limma)
targets <- readTargets("data/weaverfull/targets.txt")
rownames(targets) <- removeExt(targets$FileName)
targets
```

Exploratory analysis showed that the segmented area for spots for these arrays was quite variable, with a median spot area just over 50 pixels. A small proportion of spots had very small segmented sizes, suggesting that the intensities for these spots might be unreliable. It was therefore decided to set a spot quality weight function, so any spot with an area less than 50 pixels will get reduced weight. The function is set so that any spot with zero area will get zero weight:

```{r}
wtfun <- function(x) pmin(x$area / 50, 1)
```

Then read the SPOT files containing the intensity data using file names recorded in the targets file. The data files are stored in the subdirectory `/spot`:

```{r}
RG <- read.maimages(targets, source = "spot", path = "data/weaverfull/spot", wt.fun = wtfun)
```

Finally, we set the print-tip layout. These arrays were printed using a print-head with 8 rows and 4 columns of print tips:

```{r}
RG$printer <- list(ngrid.r = 8, ngrid.c = 4, nspot.r = 25, nspot.c = 24)
```

### Annotation

Probe annotation is contained a separate file. The rows in the annotation file are as for the intensity data. Columns give Riken chip rearray IDs, GenBank accession numbers and UniGene information.

```{r}
Annotation <- read.delim("data/weaverfull/091701RikenUpdatev3.txt", 
                         comment.char = "", quote = "\"", check.names = FALSE, stringsAsFactors = FALSE)
names(Annotation)
```

For our purposes, we will keep the Riken IDs and GenBank accessions, putting these into the data object:

```{r}
RG$genes <- Annotation[, c(1, 2)]
colnames(RG$genes) <- c("RikenID", "GenBank")
```

Where possible, we find gene symbols corresponding to the GenBank accession numbers, by using the mouse organism package constructed from the NCBI database. Symbols can be found for only a little over 5000 of the probes.

```{r}
library(org.Mm.eg.db)
```

First we find the Entrez Gene ID for each accession number:

```{r}
EG.AN <- toTable(org.Mm.egACCNUM)
i <- match(RG$genes$GenBank, EG.AN[, "accession"])
EntrezID <- EG.AN[i, "gene_id"]
```

Then convert Entrez Gene IDs to symbols:

```{r}
EG.Sym <- toTable(org.Mm.egSYMBOL)
i <- match(EntrezID, EG.Sym[, "gene_id"])
RG$genes$Symbol <- EG.Sym[i, "symbol"]
```

### Quality Assessment and Normalization

We also read in a spot-types file and set a range of control spots.

```{r}
spottypes <- readSpotTypes("spottypes.txt", path = "data/weaverfull")
spottypes
RG$genes$Status <- controlStatus(spottypes, RG)
```

MA-plots were examined for all the arrays. Here we give the plot for array 9 only:

```{r}
# CSD note, points not coloured exactly as in user guide
plotMD(RG, column = 9, xlim = c(4, 15.5))
```


Here Buffer is an obvious negative control while 18S, GAPDH, Lysine, Threonine and Tubulin are single-gene positive controls, sometime called house-keeping genes. RikenTitration is a titration series of a pool of the entire Riken library, and can be reasonably expected to be non-differentially expressed. CerEstTitration is a titration of a pool of a cerebellum EST library. This will show higher expression in later mutant tissues. The Lys, Phe and Thr series are single-gene titration series which were not spiked-in in this case and can therefore be treated as negative controls.

The negative control probe intensities are quite high, especially for the red channel and especially for array 7:

```{r}
negative <- RG$genes$Status %in% c("Buffer", "LysTitration", "PheTitration", "ThrTitration")
par(mfrow = c(1, 2))
boxplot(log2(RG$G[negative, ]), las = 2, main = "Green background", ylab = "log2-intensity", col = "green")
boxplot(log2(RG$R[negative, ]), las = 2, main = "Red background", ylab = "log2-intensity", col = "red")
par(mfrow = c(1,1))
```

Later on, we will investigate setting array quality weights.

Now normalize the data. The Riken titration library, being based on a pool of a large number
of non-specific genes, should not be differentially expressed. We can take advantage of this by upweighting these probes in the print-tip normalization step. Here we give double-weight to the titration library probes, although higher weights could also be considered:

```{r}
w <- modifyWeights(RG$weights, RG$genes$Status, "RikenTitration", 2)
MA <- normalizeWithinArrays(RG, weights = w)
```

### Setting Up the Linear Model

The experiment has a composite design, with some arrays comparing back to the RNA pool as a common reference, and other arrays making direct comparisons between the treatment conditions of interest. The simplest design matrix is that which compares all the RNA samples back to the RNA pool.

```{r}
design <- modelMatrix(targets, ref = "Pool")
```

We also add an intercept term to extract probe-specific dye effects:

```{r}
design <- cbind(Dye = 1, design)
design
```

### Probe Filtering and Array Quality Weights

First we remove control probes, leaving only the regular probes of the Riken library:

```{r}
regular <- MA$genes$Status == "Riken"
MA2 <- MA[regular, ]
MA2$genes$Status <- NULL
```

Then we estimate array quality weights:

```{r}
aw <- arrayWeights(MA2, design)
options(digits = 3)
aw
```

The array weights multiply the spot weights already in the data object:

```{r}
library(statmod)
w <- matvec(MA2$weights, aw)
```

### Differential expression

Fit the linear model:

```{r}
fit <- lmFit(MA2, design, weights = w)
```

Now extract all possible comparisons of interest as contrasts. We look for the mutant vs wt comparisons at 11 and 21 days, the time effects for mutant and wt, and the interaction terms:

```{r}
cont.matrix <- makeContrasts(
  WT11.MT11 = P11mt - P11wt,
  WT21.MT21 = P21mt - P21wt,
  WT11.WT21 = P21wt - P11wt,
  MT11.MT21 = P21mt - P11mt,
  Int = (P21mt - P11mt) - (P21wt - P11wt),
  levels = design
)
fit2 <- contrasts.fit(fit, cont.matrix)
fit2 <- eBayes(fit2)
```

Adjustment for multiple testing, using Benjamini and Hochberg’s method to control the false dis- covery rate at 5% across all genes and all contrasts, leads to the following:

```{r}
results <- decideTests(fit2, method = "global")
summary(results)
```

The probes that show significant interactions are those which develop differently in the mutant compared to the wild-type between days 11 and 21. To see these:

```{r}
topTable(fit2, coef = "Int")
sessionInfo()
```

## Bob1 Mutant Mice: Arrays with Duplicate Spots

In this section we consider a case study in which all genes (ESTs and controls) are printed more than once on the array. This means that there is both within-array and between-array replication for each gene. The structure of the experiment is therefore essentially a randomized block experiment for each gene. The approach taken here is to estimate a common correlation for all the genes for between within-array duplicates. The theory behind the approach is explained in [32]. This approach assumes that all genes are replicated the same number of times on the array and that the spacing between the replicates is entirely regular.

In this example we assume that the data is available as an `RGList`.

**Background.** This data is from a study of transcription factors critical to B cell maturation by Lynn Corcoran and Wendy Dietrich at the WEHI. Mice which have a targeted mutation in the Bob1 (aka Pou2af1 or OBF-1) transcription factor display a number of abnormalities in the B lymphocyte compartment of the immune system. Immature B cells that have emigrated from the bone marrow fail to differentiate into full fledged B cells, resulting in a notable deficit of mature B cells.

**Arrays.** Arrays were printed at the Australian Genome Research Facility with expressed sequence tags (ESTs) from the National Institute of Aging 15k mouse clone library, plus a range of positive, negative and calibration controls. The arrays were printed using a 48 tip print head and 26x26 spots in each tip group. Data from 24 of the tip groups are given here. Every gene (ESTs and controls) was printed twice on each array, side by side by rows. The NIA15k probe IDs have been anonymized in the output presented here.

**Hybridizations.** A retrovirus was used to add Bob back to a Bob deficient cell line. Two RNA sources were compared using 2 dye-swap pairs of microarrays. One RNA source was obtained from the Bob deficient cell line after the retrovirus was used to add GFP (”green fluorescent protein”, a neutral protein). The other RNA source was obtained after adding both GFP and Bob protein. RNA from Bob+GFP was labelled with Cy5 in arrays 2 and 4, and with Cy3 in arrays 1 and 4.

**Image analysis.** The arrays were image analyzed using SPOT with “morph” background estima- tion.

The data used for this case study can be downloaded from `http://bioinf.wehi.edu.au/limma/`. The file should be placed in the working directory of your R session. (This case study was last updated on 29 June 2006 using R 2.3.0 and limma 2.7.5.)

```{r}
library(limma)
load("data/Bob.RData")
# objects()
design
names(RG)
RG$genes[1:40, ]
```

Although there are only four arrays, we have a total of eight spots for each gene, and more for the controls. Naturally the two M-values obtained from duplicate spots on the same array are highly correlated. The problem is how to make use of the duplicate spots in the best way. The approach taken here is to estimate the spatial correlation between the adjacent spots using REML and then to conduct the usual analysis of the arrays using generalized least squares.

First normalize the data using print-tip loess regression. The SPOT morph background ensures that the default background subtraction can be used without inducing negative intensities.

```{r}
MA <- normalizeWithinArrays(RG)
```

Then remove the control probes:

```{r}
MA2 <- MA[MA$genes$Library == "NIA15k", ]
```

Now estimate the spatial correlation. We estimate a correlation term by REML for each gene, and then take a trimmed mean on the atanh scale to estimate the overall correlation. This command will probably take at least a few minutes depending on the speed of your computer.

```{r}
options(digits = 3)
corfit <- duplicateCorrelation(MA2, design, ndups = 2) # A slow computation!
corfit$consensus.correlation
boxplot(tanh(corfit$atanh.correlations))
fit <- lmFit(MA2, design, ndups = 2, correlation = corfit$consensus)
fit <- eBayes(fit)
topTable(fit, n = 30)
volcanoplot(fit)
```

# Single-Channel Case Studies

## Lrp Mutant _E. Coli_ Strain with Affymetrix Arrays

### Background

Gene expression in two _Escherichia coli_ bacteria strains, labelled lrp+ and lrp-, were compared using eight Affymetrix _E. coli_ chips, four chips each for lrp+ and lrp-. The data are from experiments reported in [11], who state that

> The purpose of the work presented here is to identify the network of genes that are differentially regulated by the global _E. coli_ regulatory protein, leucine-responsive regulatory protein (Lrp), during steady state growth in a glucose supplemented minimal salts medium. Lrp is a DNA-binding protein that has been reported to affect the expression of approximately 55 genes.

### Downloading the data

The raw data files can be downloaded from http://bioinf.wehi.edu.au/limma/. The 
following code assumes that the files in your current working directory:

```{r}
dir("data/ecoli")
```

The file `targets.txt` describes the design of the experiment:

```{r}
library(limma)
targets <- readTargets("data/ecoli/targets.txt")
targets
```

The lrp- samples are from the Lrp-deficient strain while the lrp+ are from the wild-type strain. The data was collected in four batches or “experiments”.

### Background correction and normalization

The data is read and normalized using the affy package. The package ecolicdf must also be installed, otherwise the `rma()` function will attempt to download and install it for you.

```{r}
library(affy)
eset <- justRMA(filenames = paste0("data/ecoli/", targets$FileName)) # This needed to install ecolicdf package??
colnames(eset) <- row.names(targets)
head(exprs(eset))
```

The rownames of the expression matrix combine the gene symbols (aas) with an open reading frame identifier (b2836). This format is idiosyncratic to this historical GeneChip.

An MDS plot shows clearly that there is a batch effect between the four experiments:

```{r}
plotMDS(eset)
```

### Gene annotation

The gene information file `Escherichia coli str. K-12 substr. MG1655.gene info.gz` was downloaded from the NCBI ftp site at ftp://ftp.ncbi.nlm.nih.gov/gene/DATA/GENE_INFO. We can use this file to update the gene annotation.

First we extract the old gene symbols from the rownames:

```{r}
Alias <- sub("_.*", "", row.names(eset))
Alias[1:5]
```

Then we use limma function `alias2SymbolUsingNCBI` to update the old gene symbols to current symbols and associated information. The information is stored in the fData slot of the ExpressionSet:

```{r}
GeneInfo <- "data/ecoli/Escherichia_coli_str._K-12_substr._MG1655.gene_info.gz"
fData(eset) <- alias2SymbolUsingNCBI(
  Alias, GeneInfo,
  required.columns = c("GeneID", "Symbol", "type_of_gene")
)
head(fData(eset))
```

We remove all probes that do not have an Entrez Gene ID and Symbol:

```{r}
HasSymbol <- !is.na(fData(eset)$Symbol)
eset <- eset[HasSymbol, ]
dim(eset)
```

### Differential expression

Make factors for the Experiment and Strain:

```{r}
Exp <- factor(targets$Experiment)
Strain <- factor(targets$Strain, levels = c("lrp+", "lrp-"))
```

Then construct the design matrix, with Experiment and Strain. This will allow us to test for Strain differences adjusting for differences between the Experiments:

```{r}
design <- model.matrix(~Exp+Strain)
```

Now we can run the differential expression pipeline:

```{r}
fit <- lmFit(eset, design)
fit <- eBayes(fit, trend = TRUE, robust = TRUE)
results <- decideTests(fit)
summary(results)
```

There are 82 up-regulated and 101 down-regulated genes in the Lrp- strain at FDR<0.05. Including Experiment as a batch was also clearly important.

The top 30 differentially expressed genes can be seen:

```{r}
topTable(fit, coef = "Strainlrp-", n = 30)
```

Lrp itself is the 11th gene in the list.

We can plot the fold-changes for the significant genes:

```{r}
plotMD(fit, coef = "Strainlrp-", status = results)
```

## Effect of Estrogen on Breast Cancer Tumor Cells: A 2x2 Factorial Experiment with Affymetrix Array

This data is from the estrogen package on Bioconductor. A subset of the data is also analyzed in the factDesign package vignette. To repeat this case study you will need to have the R packages affy, estrogen and hgu95av2cdf installed.

The data gives results from a 2x2 factorial experiment on MCF7 breast cancer cells using Affymetrix HGU95av2 arrays. The factors in this experiment were estrogen (present or absent) and length of exposure (10 or 48 hours). The aim of the study is the identify genes which respond to estrogen and to classify these into early and late responders. Genes which respond early are putative direct-target genes while those which respond late are probably downstream targets in the molecular pathway.

First load the required packages:

```{r}
library(limma)
library(affy)
library(hgu95av2cdf)
```

The data files are contained in the `extdata` directory of the estrogen package.

```{r}
datadir <- file.path(find.package("estrogen"), "extdata")
dir(datadir)
```

The targets file is called phenoData.txt. We see there are two arrays for each experimental condition, giving a total of 8 arrays.

```{r}
targets <- readTargets("phenoData.txt", path = datadir, sep = "", row.names = "filename")
targets
```

Now read the cel files into an AffyBatch object and normalize using the `rma()` function from the affy package:

```{r}
ab <- ReadAffy(filenames = targets$filename, celfile.path = datadir)
eset <- rma(ab)
```

By default, the only probe-set annotation contained in `eset` is the Affymetrix ID number. We will add gene symbols to the data object now, so that they will be automatically included in limma results tables later on.

```{r}
library(annotate)
library(hgu95av2.db)
ID <- featureNames(eset)
Symbol <- getSYMBOL(ID,"hgu95av2.db")
fData(eset) <- data.frame(Symbol = Symbol)
```

There are many ways to construct a design matrix for this experiment. Given that we are interested in the early and late estrogen responders, we can choose a parametrization which includes these two contrasts.

```{r}
treatments <- factor(
  c(1, 1, 2, 2, 3, 3, 4, 4),
  labels = c("e10", "E10", "e48", "E48")
)
contrasts(treatments) <- cbind(
  Time = c(0, 0, 1, 1),
  E10 = c(0, 1, 0, 0),
  E48 = c(0, 0, 0, 1)
)
design <- model.matrix(~treatments)
colnames(design) <- c("Intercept", "Time", "E10", "E48")
```

The second coefficient picks up the effect of time in the absence of estrogen. The third and fourth coefficients estimate the log2-fold change for estrogen at 10 hours and 48 hours respectively.

```{r}
fit <- lmFit(eset, design)
```

We are only interested in the estrogen effects, so we choose a contrast matrix which picks these
two coefficients out:

```{r}
cont.matrix <- cbind(
  E10 = c(0, 0, 1, 0),
  E48 = c(0, 0, 0, 1)
)
fit2 <- contrasts.fit(fit, cont.matrix)
fit2 <- eBayes(fit2)
```

We can examine which genes respond to estrogen at either time using the moderated F-statistics on 2 degrees of freedom. The moderated F p-value is stored in the component `fit2$F.p.value`.

What p-value cutoff should be used? One way to decide which changes are significant for each gene would be to use Benjamini and Hochberg’s method to control the false discovery rate across all the genes and both tests:

```{r}
results <- decideTests(fit2, method = "global")
```

Another method would be to adjust the F-test p-values rather than the t-test p-values:

```{r}
results <- decideTests(fit2, method = "nestedF")
```

Here we use a more conservative method which depends far less on distributional assumptions, which is to make use of control and spike-in probe-sets which theoretically should not be differentially-expressed. The smallest p-value amongst these controls turns out to be about 0.00014:

```{r}
i <- grep("AFFX", featureNames(eset))
summary(fit2$F.p.value[i])
```

So a cutoff p-value of 0.0001, say, would conservatively avoid selecting any of the control probe-sets as differentially expressed:

```{r}
results <- classifyTestsF(fit2, p.value = 0.0001)
summary(results)
table(E10 = results[, 1], E48 = results[, 2])
vennDiagram(results, include = "up")
vennDiagram(results,include="down")
```

We see that 87 genes were up regulated at both 10 and 48 hours, 29 only at 10 hours and 52 only at 48 hours. Also, 29 genes were down-regulated throughout, 11 only at 10 hours and 47 only at 48 hours. No genes were up at one time and down at the other. `topTable` gives a detailed look at individual genes. Estrogen effect at 10 hours:

```{r}
options(digits = 3)
topTable(fit2, coef = "E10", n = 20)
sessionInfo()
```




